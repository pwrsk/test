print("yo just wait untill game is fully loaded, dont execute it one more time.")

local platform = Instance.new("Part")
platform.Name = "InvisiblePlatform"
platform.Size = Vector3.new(10000, 0.1, 10000)
platform.Position = Vector3.new(0, -50000, 0)
platform.Anchored = true
platform.Transparency = 1
platform.CanCollide = true
platform.Parent = game.Workspace

    game.Workspace.FallenPartsDestroyHeight = -50000

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/pwrsk/dh/main/lib", true))()

local main = library:Load({Name = "zinnyx.geek", Theme = "Light", SizeX = 440, SizeY = 480, ColorOverrides = {}})
local legit = main:Tab("Main")
local visuals = main:Tab("Visuals")
local player = main:Tab("Local Player")
local misc = main:Tab("Misc")
local section = legit:Section({Name = "-----//Aimlock//-----", column = 1})
local features = legit:Section({Name = "-----//Features//-----", column = 2})
local esp = visuals:Section({Name = "-----//ESP//-----", column = 1})
local world = visuals:Section({Name = "-----//World//-----", column = 2})
local movement = player:Section({Name = "-----//Movement//-----", column = 1})
local playerfeatures = player:Section({Name = "-----//Features//-----", column = 2})

local antilockEnabled = false
getgenv().SkyAmount = 720

local function Antilock()
    if antilockEnabled then
        local vel = game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity
        game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, getgenv().SkyAmount, 0)
        game:GetService("RunService").RenderStepped:Wait()
        game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = vel
    end
end

game:GetService("RunService").heartbeat:Connect(Antilock)

local toggle = section:Toggle({
    Name = "Anti Lock",
    Flag = "Toggle",
    callback = function(bool)
        antilockEnabled = bool
    end
})

local camera = workspace.CurrentCamera

local aimLockEnabled = false
local aimLockActive = false
local targetPlayer = nil
local fovDistance = 40

-- Переменные для предсказания
local predictionXZ = 0.224
local predictionY = 0.173

-- Переменная для K.O Check
local koCheckEnabled = false

-- Переменная для Show Stats
local showStatsEnabled = false

-- Функция для поиска ближайшего игрока к курсору в определенном радиусе
local function getClosestPlayerToMouse()
    local player = game.Players.LocalPlayer
    local mouse = player:GetMouse()
    local closestPlayer = nil
    local closestDistance = fovDistance

    for _, plr in pairs(game.Players:GetPlayers()) do
        if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (mouse.Hit.p - plr.Character.HumanoidRootPart.Position).magnitude
            
            if distance < closestDistance then
                closestDistance = distance
                closestPlayer = plr
            end
        end
    end

    return closestPlayer
end

-- Функция для проверки состояния K.O игрока
local function checkKO(player)
    if player and player.Character and player.Character:FindFirstChild("BodyEffects") and player.Character.BodyEffects:FindFirstChild("K.O") then
        return player.Character.BodyEffects["K.O"].Value
    end
    return false
end

-- Подключаем функцию к RenderStepped для постоянного обновления позиции камеры
game:GetService("RunService").RenderStepped:Connect(function()
    if aimLockActive and targetPlayer and targetPlayer.Character then
        local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
        local velocity = targetPlayer.Character.HumanoidRootPart.Velocity
        
        local predictedPosition = targetPosition + Vector3.new(velocity.X * predictionXZ, velocity.Y * predictionY, velocity.Z * predictionXZ)
        camera.CFrame = CFrame.new(camera.CFrame.Position, predictedPosition)
    end
end)

-- Toggle для включения/выключения aimlock
local toggle = section:Toggle({
    Name = "Toggle",
    Flag = "Toggle",
    callback = function(bool)
        aimLockEnabled = bool
        print(bool)
    end
})

-- Keybind для активации aimlock
local keybind = section:Keybind({
    Name = "Keybind",
    Default = Enum.KeyCode.C,
    Flag = "Keybind",
    Callback = function(key)
        if aimLockEnabled then
            aimLockActive = not aimLockActive
            
            if aimLockActive then
                targetPlayer = getClosestPlayerToMouse()
                
                if targetPlayer then
                    local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
                    
                    if koCheckEnabled and checkKO(targetPlayer) then
                        aimLockActive = false
                    else
                        camera.CFrame = CFrame.new(camera.CFrame.Position, targetPosition)
                    end
                else
                    aimLockActive = false
                end
            end
        end
    end
})

-- Слайдер для предсказания по осям X и Z
local sliderXZ = section:Slider({
    Name = "Prediction X Z",
    Min = 0,
    Max = 1000,
    Default = 224,
    Flag = "SliderXZ",
    Callback = function(value)
        predictionXZ = value / 1000
    end
})

-- Слайдер для предсказания по оси Y
local sliderY = section:Slider({
    Name = "Prediction Y",
    Min = 0,
    Max = 1000,
    Default = 173,
    Flag = "SliderY",
    Callback = function(value)
        predictionY = value / 1000
    end
})

-- Слайдер для изменения FOV срабатывания aimlock
local fovSlider = section:Slider({
    Name = "Activation FOV",
    Min = 10,
    Max = 360,
    Default = 20,
    Flag = "FOVSlider",
    Callback = function(value)
        fovDistance = value
    end
})

local koCheckToggle = section:Toggle({
    Name = "K.O Check",
    Flag = "KOCheck",
    callback = function(bool)
        koCheckEnabled = bool
        print(bool)
    end
})

local Players = game:GetService("Players")

local function NoRecoil()
    for _, v in pairs(workspace:GetChildren()) do
        if v:IsA('Camera') then
            v:Destroy()
        end
    end

    local newcam = Instance.new('Camera', workspace)
    newcam.Name = 'Camera'
    newcam.CameraType = Enum.CameraType.Custom

    local player = Players.LocalPlayer
    local character = workspace.Players:FindFirstChild(player.Name)

    if character then
        newcam.CameraSubject = character:FindFirstChild('Humanoid')
        newcam.HeadLocked = true
        newcam.HeadScale = 1

        workspace.CurrentCamera = newcam
    end
end

local running = false

local function setupCharacter(character)
    if running then
        task.wait(5)
        NoRecoil()
    end
end

local function startNoRecoil()
    running = true
    NoRecoil()

    Players.LocalPlayer.CharacterAdded:Connect(setupCharacter)
end

local function stopNoRecoil()
    running = false
end

local toggle = features:Toggle({
    Name = "No recoil",
    Flag = "Toggle",
    callback = function(bool)
        if bool then
            startNoRecoil()
        else
            stopNoRecoil()
        end
    end
})

if toggle.Value then
    startNoRecoil()
end

local RunService = game:GetService("RunService")
local MainEvent = game.ReplicatedStorage:FindFirstChild("MainEvent")
local scriptEnabled = false

if not MainEvent then
    MainEvent = game.Workspace:FindFirstChild("MainEvent")
end

if not MainEvent then
    return
end

local function executeStomp()
    if scriptEnabled then
        MainEvent:FireServer('Stomp')
    end
end

RunService.Heartbeat:Connect(executeStomp)

local toggle = features:Toggle({
    Name = "Auto Stomp",
    Flag = "Toggle",
    callback = function(bool)
        scriptEnabled = bool
    end
})

local player = game.Players.LocalPlayer
local MainEvent = game:GetService("ReplicatedStorage"):WaitForChild("MainEvent")

local Loop
local attackEndTime = 0

local keytoclick = "F"

local function sendKeyPress()
    local vim = game:GetService("VirtualInputManager")
    vim:SendKeyEvent(true, Enum.KeyCode[keytoclick], false, game)
    wait(0.01)
    vim:SendKeyEvent(false, Enum.KeyCode[keytoclick], false, game)
end

local function loopFunction()
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (otherPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance <= 6 and otherPlayer.Character:FindFirstChild("BodyEffects") then
                local attackingValue = otherPlayer.Character.BodyEffects:FindFirstChild("Attacking")
                local tool = otherPlayer.Character:FindFirstChildOfClass("Tool")
                if tool and (tool.Name == "Combat" or tool.Name == "[Knife]" or tool.Name == "[SledgeHammer]" or tool.Name == "[Bat]") then
                    if attackingValue and attackingValue.Value == true then
                        attackEndTime = tick() + 1
                        sendKeyPress()
                    elseif tick() < attackEndTime then
                        sendKeyPress()
                    end
                end
            end
        end
    end
end

local function Start()
    Loop = game:GetService("RunService").Heartbeat:Connect(loopFunction)
end

local function Pause()
    if Loop then
        Loop:Disconnect()
        Loop = nil
    end
end

local toggle = features:Toggle({
    Name = "Auto Block",
    Flag = "Toggle",
    callback = function(bool)
        if bool then
            Start()
        else
            Pause()
        end
    end
})

local player = game.Players.LocalPlayer
local originalPosition = nil
local antiRPGEnabled = false
local heartbeatConnection = nil

local function createFrozenPlatform()
    local platform = Instance.new("Part")
    platform.Name = "FrozenPlatform"
    platform.Anchored = true
    platform.CanCollide = true
    platform.Size = Vector3.new(10, 1, 10)
    platform.Position = Vector3.new(10000, 10000, 10000)
    platform.Parent = game.Workspace
    return platform
end

local function teleportPlayer(position)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(position)
    end
end

local function checkLauncher()
    local launcher = game.Workspace.Ignored.Model:FindFirstChild("Launcher")
    if launcher and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local distance = (launcher.Position - player.Character.HumanoidRootPart.Position).Magnitude
        if distance <= 15 then
            originalPosition = player.Character.HumanoidRootPart.Position
            teleportPlayer(Vector3.new(10000, 10000, 10000))
            local platform = createFrozenPlatform()
            wait(0.7)
            teleportPlayer(originalPosition)
            platform:Destroy()
        end
    end
end

local function toggleAntiRPG(state)
    if state then
        if not heartbeatConnection then
            heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(checkLauncher)
        end
    else
        if heartbeatConnection then
            heartbeatConnection:Disconnect()
            heartbeatConnection = nil
        end
    end
end

local toggle = features:Toggle({
    Name = "Anti RPG",
    Flag = "Toggle",
    callback = function(bool)
        antiRPGEnabled = bool
        toggleAntiRPG(bool)
    end
})

local button = features:Button({Name = "Target HUD", Callback = function()
local UserInputService, Players, TweenService, Camera = game:GetService("UserInputService"), game:GetService("Players"), game:GetService("TweenService"), game.Workspace.CurrentCamera

local TargetUI = Instance.new("ScreenGui")
TargetUI.Name = "TargetUI"
TargetUI.ResetOnSpawn = false
TargetUI.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local OutlineFrame = Instance.new("Frame")
OutlineFrame.Name = "OutlineFrame"
OutlineFrame.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
OutlineFrame.BorderSizePixel = 0
OutlineFrame.Position = UDim2.new(0.5, -130, 0.85, -30)
OutlineFrame.Size = UDim2.new(0, 260, 0, 80)
OutlineFrame.Visible = false
OutlineFrame.Parent = TargetUI

local Frame = Instance.new("Frame")
Frame.Name = "TargetFrame"
Frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0, 5, 0, 5)
Frame.Size = UDim2.new(0, 250, 0, 70)
Frame.Visible = false
Frame.Parent = OutlineFrame

local ProfileImage = Instance.new("ImageLabel")
ProfileImage.Name = "ProfileImage"
ProfileImage.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ProfileImage.BackgroundTransparency = 1
ProfileImage.Position = UDim2.new(0, 5, 0, 5)
ProfileImage.Size = UDim2.new(0, 60, 0, 60)
ProfileImage.Image = ""
ProfileImage.Parent = Frame

local ScreenName = Instance.new("TextLabel")
ScreenName.Name = "ScreenName"
ScreenName.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ScreenName.BackgroundTransparency = 1
ScreenName.Position = UDim2.new(0, 70, 0, 5)
ScreenName.Size = UDim2.new(0, 175, 0, 20)
ScreenName.Font = Enum.Font.SourceSansBold
ScreenName.TextColor3 = Color3.fromRGB(255, 255, 255)
ScreenName.TextSize = 16
ScreenName.TextXAlignment = Enum.TextXAlignment.Left
ScreenName.Parent = Frame

local RealName = Instance.new("TextLabel")
RealName.Name = "RealName"
RealName.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
RealName.BackgroundTransparency = 1
RealName.Position = UDim2.new(0, 70, 0, 25)
RealName.Size = UDim2.new(0, 175, 0, 20)
RealName.Font = Enum.Font.SourceSansBold
RealName.TextColor3 = Color3.fromRGB(255, 255, 255)
RealName.TextSize = 16
RealName.TextXAlignment = Enum.TextXAlignment.Left
RealName.Parent = Frame

local HealthBackground = Instance.new("Frame")
HealthBackground.Name = "HealthBackground"
HealthBackground.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
HealthBackground.BorderSizePixel = 0
HealthBackground.Position = UDim2.new(0, 70, 0, 45)
HealthBackground.Size = UDim2.new(0, 175, 0, 10)
HealthBackground.Parent = Frame

local HealthBar = Instance.new("Frame")
HealthBar.Name = "HealthBar"
HealthBar.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
HealthBar.BorderSizePixel = 0
HealthBar.Position = UDim2.new(0, 0, 0, 0)
HealthBar.Size = UDim2.new(1, 0, 1, 0)
HealthBar.Parent = HealthBackground

local HealthText = Instance.new("TextLabel")
HealthText.Name = "HealthText"
HealthText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
HealthText.BackgroundTransparency = 1
HealthText.Position = UDim2.new(0.5, -50, 0, 0)
HealthText.Size = UDim2.new(0, 100, 0, 10)
HealthText.Font = Enum.Font.SourceSansBold
HealthText.TextColor3 = Color3.fromRGB(255, 255, 255)
HealthText.TextSize = 14
HealthText.TextXAlignment = Enum.TextXAlignment.Center
HealthText.Parent = HealthBackground

local ArmorBackground = Instance.new("Frame")
ArmorBackground.Name = "ArmorBackground"
ArmorBackground.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
ArmorBackground.BorderSizePixel = 0
ArmorBackground.Position = UDim2.new(0, 70, 0, 60)
ArmorBackground.Size = UDim2.new(0, 175, 0, 10)
ArmorBackground.Parent = Frame

local ArmorBar = Instance.new("Frame")
ArmorBar.Name = "ArmorBar"
ArmorBar.BackgroundColor3 = Color3.fromRGB(0, 0, 255)
ArmorBar.BorderSizePixel = 0
ArmorBar.Position = UDim2.new(0, 0, 0, 0)
ArmorBar.Size = UDim2.new(1, 0, 1, 0)
ArmorBar.Parent = ArmorBackground

local ArmorText = Instance.new("TextLabel")
ArmorText.Name = "ArmorText"
ArmorText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ArmorText.BackgroundTransparency = 1
ArmorText.Position = UDim2.new(0.5, -50, 0, 0)
ArmorText.Size = UDim2.new(0, 100, 0, 10)
ArmorText.Font = Enum.Font.SourceSansBold
ArmorText.TextColor3 = Color3.fromRGB(255, 255, 255)
ArmorText.TextSize = 14
ArmorText.TextXAlignment = Enum.TextXAlignment.Center
ArmorText.Parent = ArmorBackground

local function FindNearestPlayerToCursor()
    local mousePosition = UserInputService:GetMouseLocation()
    local nearestPlayer = nil
    local nearestDistance = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local screenPosition, onScreen = Camera:WorldToScreenPoint(player.Character.HumanoidRootPart.Position)
            if onScreen then
                local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - mousePosition).Magnitude
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestPlayer = player
                end
            end
        end
    end

    return nearestPlayer, nearestDistance
end

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        local nearestPlayer, distanceToPlayer = FindNearestPlayerToCursor()
        if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("Humanoid") then
            if distanceToPlayer < 100 then
            else
                Frame.Visible = false
                OutlineFrame.Visible = false
            end
        else
            Frame.Visible = false
            OutlineFrame.Visible = false
        end
    end
end)


local function AdjustTextSize(textLabel, maxWidth)
    local textSize = textLabel.TextSize
    local text = textLabel.Text
    local font = textLabel.Font
    local textService = game:GetService("TextService")

    while textService:GetTextSize(text, textSize, font, Vector2.new(maxWidth, 100)).X > maxWidth do
        textSize = textSize - 1
    end

    textLabel.TextSize = textSize
end

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        local nearestPlayer = FindNearestPlayerToCursor()
        if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("Humanoid") then
            local health = nearestPlayer.Character.Humanoid.Health
            local maxHealth = nearestPlayer.Character.Humanoid.MaxHealth
            local healthPercentage = health / maxHealth

            ScreenName.Text = nearestPlayer.DisplayName
            RealName.Text = "(" .. nearestPlayer.Name .. ")"

            AdjustTextSize(ScreenName, 175)
            AdjustTextSize(RealName, 175)

            HealthBar.Size = UDim2.new(healthPercentage, 0, 1, 0)
            HealthText.Text = string.format("%.0f%%", healthPercentage * 100)

            local armor = nearestPlayer.Character:FindFirstChild("BodyEffects") and nearestPlayer.Character.BodyEffects:FindFirstChild("Armor")
            if armor then
                local armorValue = armor.Value
                local armorPercentage = armorValue / 130
                ArmorBar.Size = UDim2.new(armorPercentage, 0, 1, 0)
                ArmorText.Text = string.format("%.0f%%", armorPercentage * 100)
            else
                ArmorBar.Size = UDim2.new(0, 0, 1, 0)
                ArmorText.Text = "0%"
            end

            ProfileImage.Image = "rbxthumb://type=AvatarHeadShot&id=" .. nearestPlayer.UserId .. "&w=420&h=420"
            Frame.Visible = true
            OutlineFrame.Visible = true
        else
            Frame.Visible = false
            OutlineFrame.Visible = false
        end
    end
end)
end})

local button = features:Button({Name = "Animation Pack", Callback = function()
                for _, v in next, game:GetService("CoreGui"):GetChildren() do
                if (v.Name:match("FreeAnimationPack")) then
                    v:Destroy()
                end
            end
        
            
            local FreeAnimationPack, AnimationPack, Animations, UIListLayout, Lean, Lay, Dance1, Dance2, Greet, ChestPump, Praying, Stop, UniversalAnimation = Instance.new("ScreenGui"), Instance.new("TextButton"), Instance.new("ScrollingFrame"), Instance.new("UIListLayout"), Instance.new("TextButton"), Instance.new("TextButton"), Instance.new("TextButton"), Instance.new("TextButton"), Instance.new("TextButton"), Instance.new("TextButton"), Instance.new("TextButton"), Instance.new("TextButton"), Instance.new("Animation")
        
            
            function stopTracks()
                for _, v in next, game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):GetPlayingAnimationTracks() do
                    if (v.Animation.AnimationId:match("rbxassetid")) then
                        v:Stop()
                    end
                end
            end
        
            function loadAnimation(id)
                if UniversalAnimation.AnimationId == id then
                    stopTracks()
                    UniversalAnimation.AnimationId = "1"
                else
                    UniversalAnimation.AnimationId = id
                    local animationTrack = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):LoadAnimation(UniversalAnimation)
                    animationTrack:Play()
                end
            end
        

            FreeAnimationPack.Name = "FreeAnimationPack"
            FreeAnimationPack.Parent = game.CoreGui
            FreeAnimationPack.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        
            AnimationPack.Name = "AnimationPack"
            AnimationPack.Parent = FreeAnimationPack
            AnimationPack.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            AnimationPack.BorderSizePixel = 0
            AnimationPack.Position = UDim2.new(0, 0, 0.388007045, 0)
            AnimationPack.Size = UDim2.new(0, 100, 0, 20)
            AnimationPack.Font = Enum.Font.SourceSansBold
            AnimationPack.Text = "Animations"
            AnimationPack.TextColor3 = Color3.fromRGB(0, 0, 0)
            AnimationPack.TextSize = 18.000
            AnimationPack.MouseButton1Click:Connect(function()
                if (Animations.Visible == false) then
                    Animations.Visible = true
                end
            end)
        
            Animations.Name = "Animations"
            Animations.Parent = AnimationPack
            Animations.Active = true
            Animations.BackgroundColor3 = Color3.fromRGB(102, 102, 102)
            Animations.Position = UDim2.new(-0.104712225, 0, -1.54173493, 0)
            Animations.Size = UDim2.new(0, 120, 0, 195)
            Animations.Visible = false
            Animations.CanvasPosition = Vector2.new(0, 60.0000305)
            Animations.CanvasSize = UDim2.new(0, 0, 1, 235)
        
            UIListLayout.Parent = Animations
            UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
            UIListLayout.Padding = UDim.new(0, 2)
        
            Lean.Name = "Lean"
            Lean.Parent = Animations
            Lean.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            Lean.Size = UDim2.new(1, 0, 0, 30)
            Lean.Font = Enum.Font.SourceSansBold
            Lean.Text = "Lean"
            Lean.TextColor3 = Color3.fromRGB(0, 0, 0)
            Lean.TextSize = 14.000
            Lean.MouseButton1Click:Connect(function()
                stopTracks()
                loadAnimation("rbxassetid://3152375249")
            end)
        
            Lay.Name = "Lay"
            Lay.Parent = Animations
            Lay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            Lay.Size = UDim2.new(1, 0, 0, 30)
            Lay.Font = Enum.Font.SourceSansBold
            Lay.Text = "Lay"
            Lay.TextColor3 = Color3.fromRGB(0, 0, 0)
            Lay.TextSize = 14.000
            Lay.MouseButton1Click:Connect(function()
                stopTracks()
                loadAnimation("rbxassetid://3152378852")
            end)
        
            Dance1.Name = "Dance1"
            Dance1.Parent = Animations
            Dance1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            Dance1.Size = UDim2.new(1, 0, 0, 30)
            Dance1.Font = Enum.Font.SourceSansBold
            Dance1.Text = "Dance1"
            Dance1.TextColor3 = Color3.fromRGB(0, 0, 0)
            Dance1.TextSize = 14.000
            Dance1.MouseButton1Click:Connect(function()
                stopTracks()
                loadAnimation("rbxassetid://3189773368")
            end)
        
            Dance2.Name = "Dance2"
            Dance2.Parent = Animations
            Dance2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            Dance2.Size = UDim2.new(1, 0, 0, 30)
            Dance2.Font = Enum.Font.SourceSansBold
            Dance2.Text = "Dance2"
            Dance2.TextColor3 = Color3.fromRGB(0, 0, 0)
            Dance2.TextSize = 14.000
            Dance2.MouseButton1Click:Connect(function()
                stopTracks()
                loadAnimation("rbxassetid://3189776546")
            end)
        
            Greet.Name = "Greet"
            Greet.Parent = Animations
            Greet.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            Greet.Size = UDim2.new(1, 0, 0, 30)
            Greet.Font = Enum.Font.SourceSansBold
            Greet.Text = "Greet"
            Greet.TextColor3 = Color3.fromRGB(0, 0, 0)
            Greet.TextSize = 14.000
            Greet.MouseButton1Click:Connect(function()
                stopTracks()
                loadAnimation("rbxassetid://3189777795")
            end)
        
            ChestPump.Name = "ChestPump"
            ChestPump.Parent = Animations
            ChestPump.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            ChestPump.Size = UDim2.new(1, 0, 0, 30)
            ChestPump.Font = Enum.Font.SourceSansBold
            ChestPump.Text = "Chest Pump"
            ChestPump.TextColor3 = Color3.fromRGB(0, 0, 0)
            ChestPump.TextSize = 14.000
            ChestPump.MouseButton1Click:Connect(function()
                stopTracks()
                loadAnimation("rbxassetid://3189779152")
            end)
        
            Praying.Name = "Praying"
            Praying.Parent = Animations
            Praying.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            Praying.Size = UDim2.new(1, 0, 0, 30)
            Praying.Font = Enum.Font.SourceSansBold
            Praying.Text = "Praying"
            Praying.TextColor3 = Color3.fromRGB(0, 0, 0)
            Praying.TextSize = 14.000
            Praying.MouseButton1Click:Connect(function()
                stopTracks()
                loadAnimation("rbxassetid://3487719500")
            end)
        
            Stop.Name = "Stop"
            Stop.Parent = Animations
            Stop.BackgroundColor3 = Color3.fromRGB(255, 112, 112)
            Stop.Size = UDim2.new(1, 0, 0, 30)
            Stop.Font = Enum.Font.SourceSansBold
            Stop.Text = "Stop Animation"
            Stop.TextColor3 = Color3.fromRGB(0, 0, 0)
            Stop.TextSize = 14.000
            Stop.MouseButton1Click:Connect(function()
                stopTracks()
            end)
            
            local plr = game.Players.LocalPlayer
        
            plr:GetMouse().KeyDown:Connect(function(K)
                if K == "p" then
                    Animations.Visible = false
                end
            end)
        warn("loaded")
end})

local G_UserInputService = game:GetService("UserInputService")
local G_TweenService = game:GetService("TweenService")
local G_player = game.Players.LocalPlayer

local G_originalPosition = nil
local G_targetPart = nil
local G_enabled = false
local G_activationKey = Enum.KeyCode.T

function tweenTo(part, goal, duration)
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tween = G_TweenService:Create(part, tweenInfo, goal)
    tween:Play()
end

function onInputBegan(input, gameProcessedEvent)
    if input.KeyCode == G_activationKey and not G_UserInputService:GetFocusedTextBox() and G_enabled then
        local character = G_player.Character
        if character then
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoidRootPart and humanoid then
                G_originalPosition = humanoidRootPart.CFrame

                G_targetPart = Instance.new("Part")
                G_targetPart.Name = "TargetPart"
                G_targetPart.Shape = Enum.PartType.Ball
                G_targetPart.Size = Vector3.new(1, 1, 1)
                G_targetPart.Transparency = 1
                G_targetPart.CFrame = humanoidRootPart.CFrame
                G_targetPart.Anchored = true
                G_targetPart.Parent = workspace

                workspace.CurrentCamera.CameraSubject = G_targetPart

                tweenTo(humanoidRootPart, {CFrame = CFrame.new(0, -49999, 0)}, 2)

                delay(2.1, function()
                    humanoid.PlatformStand = true
                    tweenTo(humanoidRootPart, {CFrame = humanoidRootPart.CFrame * CFrame.Angles(math.rad(180), 0, 0)}, 0.5)
                    delay(1, function()
                        humanoid.PlatformStand = false
                        humanoidRootPart.CFrame = G_originalPosition

                        workspace.CurrentCamera.CameraSubject = humanoid

                        if G_targetPart then
                            G_targetPart:Destroy()
                            G_targetPart = nil
                        end
                    end)
                end)
            end
        end
    end
end

G_UserInputService.InputBegan:Connect(onInputBegan)

local toggle = features:Toggle({
    Name = "Kill targerer",
    Flag = "EnableScriptToggle",
    callback = function(bool)
        G_enabled = bool
    end
})

local G_originalPosition = nil

-- Функция для телепортации игрока
local function teleportPlayer(position)
    local character = G_player.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            humanoidRootPart.CFrame = position
        end
    end
end

-- Создание toggle для телепортации и возвращения
local teleportToggle = features:Toggle({
    Name = "Loop",
    Flag = "TeleportToggle",
    callback = function(bool)
        local character = G_player.Character
        if character then
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                if bool then
                    -- Запоминаем текущую позицию
                    G_originalPosition = humanoidRootPart.CFrame
                    -- Телепортируем игрока на координаты (-49995, y, z)
                    teleportPlayer(CFrame.new(humanoidRootPart.Position.X, -49995, humanoidRootPart.Position.Z))
                else
                    -- Возвращаем игрока на запомненные координаты
                    if G_originalPosition then
                        teleportPlayer(G_originalPosition)
                    end
                end
            end
        end
    end
})

local keybind = features:Keybind({
    Name = "Change Activation Key",
    Default = Enum.KeyCode.T,
    Flag = "ChangeActivationKey",
    Callback = function(newKey)
        G_activationKey = newKey
    end
})

local player = game.Players.LocalPlayer
local UIS = game:GetService("UserInputService")
local camera = game.Workspace.CurrentCamera

local fixedOffsetBelow = Vector3.new(0, -10, 0)
local fixedOffsetAbove = Vector3.new(0, 10, 0)
local isFixed = false
local isBelow = true
local fixedPlayer = nil
local originalPosition = nil
local originalCameraSubject = nil
local platform = nil
local originalCollisionSettings = {}
local activationKey = Enum.KeyCode.J
local scriptEnabled = false

local function getClosestPlayer()
    local closestDistance = math.huge
    local closestPlayer = nil
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player then
            local character = otherPlayer.Character
            if character then
                local distance = (character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = otherPlayer
                end
            end
        end
    end
    
    return closestPlayer
end

local function createPlatform(position)
    if platform then
        platform:Destroy()
    end
    platform = Instance.new("Part")
    platform.Name = "Platform"
    platform.Anchored = true
    platform.CanCollide = true
    platform.Material = Enum.Material.Concrete
    platform.Shape = Enum.PartType.Block
    platform.Size = Vector3.new(10, 1, 10)
    platform.Position = position - Vector3.new(0, 3, 0)
    platform.Parent = game.Workspace
end

local function toggleCollision(enable)
    for _, part in pairs(game.Workspace:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "Platform" then
            if enable then
                if originalCollisionSettings[part] ~= nil then
                    part.CanCollide = originalCollisionSettings[part]
                end
            else
                if part.CanCollide then
                    originalCollisionSettings[part] = part.CanCollide
                    part.CanCollide = false
                end
            end
        end
    end
end

local function onCharacterAdded(character)
    if isFixed and fixedPlayer then
        local humanoid = character:WaitForChild("Humanoid")
        camera.CameraSubject = humanoid
    end
end

game:GetService("RunService").RenderStepped:Connect(function()
    if isFixed and fixedPlayer then
        local targetPosition = fixedPlayer.Character.HumanoidRootPart.Position + (isBelow and fixedOffsetBelow or fixedOffsetAbove)
        player.Character:SetPrimaryPartCFrame(CFrame.new(targetPosition))
        createPlatform(targetPosition)
    end
end)

local function toggleFixedPosition()
    if not isFixed then
        fixedPlayer = getClosestPlayer()
        if fixedPlayer then
            isFixed = true
            isBelow = true
            originalPosition = player.Character.HumanoidRootPart.CFrame
            originalCameraSubject = camera.CameraSubject
            camera.CameraSubject = fixedPlayer.Character.Humanoid
            toggleCollision(false)
            fixedPlayer.CharacterAdded:Connect(onCharacterAdded)
        end
    else
        isFixed = false
        player.Character:SetPrimaryPartCFrame(originalPosition)
        camera.CameraSubject = originalCameraSubject
        if platform then
            platform:Destroy()
            platform = nil
        end
        toggleCollision(true)
        isBelow = not isBelow
        fixedPlayer = nil
    end
end

-- Создание toggle для включения/выключения скрипта
local scriptToggle = features:Toggle({
    Name = "Target",
    Flag = "ScriptToggle",
    callback = function(bool)
        scriptEnabled = bool
    end
})

-- Создание keybind для изменения кнопки активации
local scriptKeybind = features:Keybind({
    Name = "Script Keybind",
    Default = Enum.KeyCode.J,
    Flag = "ScriptKeybind",
    Callback = function(newKey)
        activationKey = newKey
    end
})

UIS.InputBegan:Connect(function(input, processed)
    if input.KeyCode == activationKey and not processed and not UIS:GetFocusedTextBox() and scriptEnabled then
        toggleFixedPosition()
    end
end)

local G_UserInputService = game:GetService("UserInputService")
local G_player = game.Players.LocalPlayer
local fov = 2

local G_enabled = false
local G_activationKey = Enum.KeyCode.T

-- Функция для поиска ближайшего игрока к курсору
local function getClosestPlayerToCursor()
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= G_player then
            local character = otherPlayer.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    local screenPoint = workspace.CurrentCamera:WorldToScreenPoint(humanoidRootPart.Position)
                    local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(G_player:GetMouse().X, G_player:GetMouse().Y)).magnitude
                    local cameraPosition = workspace.CurrentCamera.CFrame.Position
                    local cursorDirection = workspace.CurrentCamera:ScreenPointToRay(G_player:GetMouse().X, G_player:GetMouse().Y).Direction
                    local directionToPlayer = (humanoidRootPart.Position - cameraPosition).unit
                    local angle = math.deg(math.acos(cursorDirection:Dot(directionToPlayer)))

                    if angle <= fov and distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = otherPlayer
                    end
                end
            end
        end
    end

    return closestPlayer
end

-- Функция для телепортации игрока
local function teleportPlayer(position)
    local character = G_player.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            humanoidRootPart.CFrame = position
        end
    end
end

-- Обработка нажатия keybind
local function onInputBegan(input, gameProcessedEvent)
    if input.KeyCode == G_activationKey and not G_UserInputService:GetFocusedTextBox() and G_enabled then
        local closestPlayer = getClosestPlayerToCursor()
        if closestPlayer then
            local targetCharacter = closestPlayer.Character
            if targetCharacter then
                local targetHumanoidRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
                if targetHumanoidRootPart then
                    teleportPlayer(targetHumanoidRootPart.CFrame)
                end
            end
        end
    end
end

G_UserInputService.InputBegan:Connect(onInputBegan)

-- Создание toggle
local toggle = features:Toggle({
    Name = "Teleport to player",
    Flag = "EnableTeleportToggle",
    callback = function(bool)
        G_enabled = bool
    end
})

-- Создание keybind
local keybind = features:Keybind({
    Name = "Change Activation Key",
    Default = Enum.KeyCode.E,
    Flag = "ChangeActivationKey",
    Callback = function(newKey)
        G_activationKey = newKey
    end
})

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local math = math

local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")
local camera = workspace.CurrentCamera

local part = nil
local partActive = false
local toggleActive = false
local currentKeybind = Enum.KeyCode.Z
local movementSpeed = 10
local movementKeys = {
    [Enum.KeyCode.W] = Vector3.new(0, 0, -1),
    [Enum.KeyCode.A] = Vector3.new(-1, 0, 0),
    [Enum.KeyCode.S] = Vector3.new(0, 0, 1),
    [Enum.KeyCode.D] = Vector3.new(1, 0, 0)
}
local movementInput = {}
local movementTimer = 0
local movementInterval = 0.01 -- Уменьшен интервал для более плавного движения
local lerpAlpha = 0.1 -- Коэффициент интерполяции
local teleportInterval = 0.05 -- Интервал телепортации в секундах
local teleportTimer = 0

local function createPart()
    part = Instance.new("Part")
    part.Name = "CustomPart"
    part.Shape = Enum.PartType.Ball
    part.Material = Enum.Material.Neon
    part.Color = Color3.new(1, 1, 1) -- Красный цвет
    part.Size = Vector3.new(1, 1, 1)
    part.Anchored = true
    part.CanCollide = false
    part.Parent = workspace
    part.CFrame = rootPart.CFrame

    camera.CameraSubject = part
end

local function togglePart()
    if partActive then
        if part and part.Parent then
            rootPart.Velocity = Vector3.new(0, 0, 0) -- Сброс Velocity
            rootPart.CFrame = part.CFrame -- Телепортируем игрока на позицию блока
            part:Destroy()
            part = nil
            camera.CameraSubject = humanoid
        end
    else
        createPart()
    end
    partActive = not partActive
end

local function movePart(direction)
    if partActive and part and part.Parent then
        local currentPosition = part.Position
        local moveDirection = camera.CFrame:VectorToWorldSpace(direction)
        local newPosition = currentPosition + moveDirection * movementSpeed
        part.Position = newPosition
    end
end

local function smoothMovePart(direction)
    if partActive and part and part.Parent then
        local currentPosition = part.Position
        local moveDirection = camera.CFrame:VectorToWorldSpace(direction)
        local targetPosition = currentPosition + moveDirection * movementSpeed
        part.Position = part.Position:Lerp(targetPosition, lerpAlpha)
    end
end

local function onCharacterAdded(newCharacter)
    character = newCharacter
    rootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    if not partActive then
        camera.CameraSubject = humanoid
    end
end

local function teleportRandomly()
    if partActive and part and part.Parent then
        local radius = math.random(5000, 10000)
        local angle = math.random() * 2 * math.pi
        local x = part.Position.X + radius * math.cos(angle)
        local z = part.Position.Z + radius * math.sin(angle)
        local y = part.Position.Y + math.random(-5000, 5000) -- Случайная высота в диапазоне от -5000 до 5000 юнитов
        rootPart.Velocity = Vector3.new(0, 0, 0) -- Сброс Velocity
        rootPart.CFrame = CFrame.new(x, y, z)
    end
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)

local toggle = features:Toggle({
    Name = "Pos Desync",
    Flag = "Toggle",
    callback = function(bool)
        toggleActive = bool
    end
})

local keybind = features:Keybind({
    Name = "Keybind",
    Default = Enum.KeyCode.Z,
    Flag = "Keybind",
    Callback = function(key)
        currentKeybind = key
    end
})

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == currentKeybind and toggleActive then
        togglePart()
    elseif movementKeys[input.KeyCode] then
        movementInput[input.KeyCode] = true
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if movementKeys[input.KeyCode] then
        movementInput[input.KeyCode] = nil
    end
end)

RunService.Heartbeat:Connect(function(deltaTime)
    if partActive and part and part.Parent then
        movementTimer = movementTimer + deltaTime
        teleportTimer = teleportTimer + deltaTime
        if movementTimer >= movementInterval then
            for key, _ in pairs(movementInput) do
                smoothMovePart(movementKeys[key])
            end
            movementTimer = 0
        end
        if teleportTimer >= teleportInterval then
            teleportRandomly()
            teleportTimer = 0
        end
    end
end)

local G_UserInputService = game:GetService("UserInputService")
local G_player = game.Players.LocalPlayer

local flying = false
local bv, bav
local buttons = {W = false, S = false, A = false, D = false, Moving = false}

-- Инициализация скорости полета
getgenv().FlySpeed = 20

local G_enabled = false
local G_activationKey = Enum.KeyCode.X

local function StartFly()
    if not G_player.Character then return end
    local c = G_player.Character
    local h = c:FindFirstChildOfClass("Humanoid")
    if not h or flying then return end

    h.PlatformStand = true
    local cam = workspace.CurrentCamera

    bv = Instance.new("BodyVelocity")
    bav = Instance.new("BodyAngularVelocity")

    bv.Velocity, bv.MaxForce, bv.P = Vector3.new(0, 0, 0), Vector3.new(10000, 10000, 10000), 1000
    bav.AngularVelocity, bav.MaxTorque, bav.P = Vector3.new(0, 0, 0), Vector3.new(10000, 10000, 10000), 1000
    bv.Parent = c.Head
    bav.Parent = c.Head

    flying = true

    h.Died:connect(function() 
        EndFly()
    end)
end

local function EndFly()
    if bv then bv:Destroy() end
    if bav then bav:Destroy() end

    local c = G_player.Character
    local h = c and c:FindFirstChildOfClass("Humanoid")
    if h then h.PlatformStand = false end

    flying = false
end

local function setVec(vec)
    return vec * ((getgenv().FlySpeed or 300) / vec.Magnitude)
end

game:GetService("RunService").Heartbeat:connect(function(step)
    local c = G_player.Character
    if flying and c and c.PrimaryPart then
        local p = c.PrimaryPart.Position
        local cf = workspace.CurrentCamera.CFrame
        local ax, ay, az = cf:toEulerAnglesXYZ()
        c:SetPrimaryPartCFrame(CFrame.new(p.x, p.y, p.z) * CFrame.Angles(ax, ay, az))
        if buttons.Moving then
            local t = Vector3.new()
            if buttons.W then t = t + (setVec(cf.lookVector)) end
            if buttons.S then t = t - (setVec(cf.lookVector)) end
            if buttons.A then t = t - (setVec(cf.rightVector)) end
            if buttons.D then t = t + (setVec(cf.rightVector)) end
            c:TranslateBy(t * step)
        end
    end
end)

local function onInputBegan(input, gameProcessedEvent)
    if input.KeyCode == G_activationKey and not G_UserInputService:GetFocusedTextBox() and G_enabled then
        if flying then
            EndFly()
        else
            StartFly()
        end
    else
        for i, e in pairs(buttons) do
            if i ~= "Moving" and input.KeyCode == Enum.KeyCode[i] then
                buttons[i] = true
                buttons.Moving = true
            end
        end
    end
end

G_UserInputService.InputBegan:Connect(onInputBegan)

G_UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    local a = false
    for i, e in pairs(buttons) do
        if i ~= "Moving" then
            if input.KeyCode == Enum.KeyCode[i] then
                buttons[i] = false
            end
            if buttons[i] then a = true end
        end
    end
    buttons.Moving = a
end)

local toggle = playerfeatures:Toggle({
    Name = "Fly Toggle",
    Flag = "FlyToggle",
    Default = false,
    callback = function(bool)
        G_enabled = bool
    end
})

local keybind = playerfeatures:Keybind({
    Name = "Fly Keybind",
    Default = Enum.KeyCode.X,
    Flag = "FlyKeybind",
    Callback = function(newKey)
        G_activationKey = newKey
    end
})

local slider = playerfeatures:Slider({
    Name = "Fly Speed Slider",
    Min = 0,
    Max = 500,
    Default = 20,
    Flag = "FlySpeedSlider",
    Callback = function(value)
        getgenv().FlySpeed = value
    end
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")

local originalWalkSpeed = Humanoid.WalkSpeed
local walkSpeedConnection = nil

local toggle = movement:Toggle({
    Name = "No slowdown",
    Flag = "No slow down",
    callback = function(bool)
        if bool then
            local function onWalkSpeedChanged()
                if Humanoid.WalkSpeed < 16 then
                    Humanoid.WalkSpeed = originalWalkSpeed
                end
            end

            if walkSpeedConnection then
                walkSpeedConnection:Disconnect()
            end

            walkSpeedConnection = Humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(onWalkSpeedChanged)
        else
            if walkSpeedConnection then
                walkSpeedConnection:Disconnect()
                walkSpeedConnection = nil
            end
        end
    end
})

-- Подключаем функцию защиты при добавлении нового персонажа
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    originalWalkSpeed = Humanoid.WalkSpeed
    if toggle.Value then
        local function onWalkSpeedChanged()
            if Humanoid.WalkSpeed < 16 then
                Humanoid.WalkSpeed = originalWalkSpeed
            end
        end

        if walkSpeedConnection then
            walkSpeedConnection:Disconnect()
        end

        walkSpeedConnection = Humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(onWalkSpeedChanged)
    end
end)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")

local originalJumpPower = Humanoid.JumpPower
local jumpPowerConnection = nil

local toggle = movement:Toggle({
    Name = "No jump cd",
    Flag = "No jump colldown",
    callback = function(bool)
        if bool then
            local function onJumpPowerChanged()
                if Humanoid.JumpPower == 0 then
                    Humanoid.JumpPower = originalJumpPower
                end
            end

            if jumpPowerConnection then
                jumpPowerConnection:Disconnect()
            end

            jumpPowerConnection = Humanoid:GetPropertyChangedSignal("JumpPower"):Connect(onJumpPowerChanged)
        else
            if jumpPowerConnection then
                jumpPowerConnection:Disconnect()
                jumpPowerConnection = nil
            end
        end
    end
})

-- Подключаем функцию защиты при добавлении нового персонажа
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    originalJumpPower = Humanoid.JumpPower
    if toggle.Value then
        local function onJumpPowerChanged()
            if Humanoid.JumpPower == 0 then
                Humanoid.JumpPower = originalJumpPower
            end
        end

        if jumpPowerConnection then
            jumpPowerConnection:Disconnect()
        end

        jumpPowerConnection = Humanoid:GetPropertyChangedSignal("JumpPower"):Connect(onJumpPowerChanged)
    end
end)

local LocalPlayer = game.Players.LocalPlayer
local AbyssSettings = {
    Speed = {Enabled = true, Motion = true, Amount = 0}, -- Инициализируем Amount в 0
    Fly = {Enabled = false},
    ApplyCFrameSpeed = true, -- Устанавливаем в true, чтобы функциональность всегда была включена
    CFrameOption = "Adjust cframe smooth" -- Добавляем переменную для выбранной опции
}

local SpeedModule = function(State)
    AbyssSettings.Speed.Enabled = State
end

local function onRenderStepped()
    if AbyssSettings.Speed.Enabled and not AbyssSettings.Fly.Enabled and AbyssSettings.ApplyCFrameSpeed then
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            local humanoid = character.Humanoid
            if humanoid.MoveDirection.Magnitude > 0 then
                if AbyssSettings.CFrameOption == "Adjust cframe smooth" then
                    if AbyssSettings.Speed.Motion then
                        character:TranslateBy(humanoid.MoveDirection * AbyssSettings.Speed.Amount / 1.5)
                    end
                elseif AbyssSettings.CFrameOption == "Adjust cframe" then
                    -- Телепортация каждые 0.5 секунд на 5 юнитов в направлении ходьбы
                    local currentTime = tick()
                    if currentTime - (character:GetAttribute("LastTeleportTime") or 0) >= 0.1 then
                        character:SetAttribute("LastTeleportTime", currentTime)
                        character:TranslateBy(humanoid.MoveDirection * AbyssSettings.Speed.Amount)
                    end
                end
            end
        end
    end
end

game:GetService("RunService").RenderStepped:Connect(onRenderStepped)

SpeedModule(true)

local slider = movement:Slider({
    Name = "CFrame Speed",
    Min = 0,
    Max = 1000,
    Default = 0,
    Flag = "CFrameSlider",
    Callback = function(CFrameSpeed)
        AbyssSettings.Speed.Amount = CFrameSpeed / 100
    end
})

local dropdown = movement:Dropdown({
    Default = "Adjust cframe smooth",
    Content = {"Adjust cframe smooth", "Adjust cframe"},
    MultiChoice = false,
    Flag = "cframeoptions",
    Callback = function(opt)
        AbyssSettings.CFrameOption = opt
    end
})

local button = esp:Button({Name = "Trash ESP", Callback = function()
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RS = game:GetService("RunService")

local function CreateHealthBar(player)
    local healthBar = Drawing.new("Square")
    healthBar.Visible = false
    healthBar.Color = Color3.new(1, 0, 0)
    healthBar.Filled = true
    healthBar.Thickness = 1
    healthBar.Transparency = 1

    local function UpdateHealthBar()
        local c; c = RS.RenderStepped:Connect(function()    
            if player and player.Character and player.Character:FindFirstChild("Humanoid") then
                local humanoid = player.Character.Humanoid
                local head = player.Character:FindFirstChild("Head")
                if head then
                    local screenPos, onScreen = Camera:WorldToScreenPoint(head.Position)
                    if onScreen then
                        healthBar.Position = Vector2.new(screenPos.X, screenPos.Y + 60)
                        healthBar.Size = Vector2.new(30, 3)
                        healthBar.Visible = true
                        healthBar.Color = Color3.new(1 - humanoid.Health / humanoid.MaxHealth, humanoid.Health / humanoid.MaxHealth, 0)
                    else
                        healthBar.Visible = false
                    end
                else
                    healthBar.Visible = false
                end
            else
                healthBar.Visible = false
            end
        end)
    end

    coroutine.wrap(UpdateHealthBar)()
    return healthBar
end

local function CreateNameTag(player)
    local nameTag = Drawing.new("Text")
    nameTag.Visible = false
    nameTag.Color = Color3.new(1, 1, 1)
    nameTag.Size = 14
    nameTag.Center = true
    nameTag.Outline = true
    nameTag.OutlineColor = Color3.new(0, 0, 0)

    local function UpdateNameTag()
        local c; c = RS.RenderStepped:Connect(function()
            if player and player.Character then
                local head = player.Character:FindFirstChild("Head")
                if head then
                    local screenPos, onScreen = Camera:WorldToScreenPoint(head.Position)
                    if onScreen then
                        nameTag.Position = Vector2.new(screenPos.X, screenPos.Y - 20)
                        nameTag.Text = player.Name
                        nameTag.Visible = true
                    else
                        nameTag.Visible = false
                    end
                else
                    nameTag.Visible = false
                end
            else
                nameTag.Visible = false
            end
        end)
    end

    coroutine.wrap(UpdateNameTag)()
    return nameTag
end

local function CreateESP(player)
    local healthBar = CreateHealthBar(player)
    local nameTag = CreateNameTag(player)

    player.CharacterAdded:Connect(function()
        healthBar.Visible = false
        nameTag.Visible = false
    end)

    player.CharacterRemoving:Connect(function()
        healthBar.Visible = false
        nameTag.Visible = false
    end)
end

for _, player in pairs(Players:GetChildren()) do
    if player ~= Player then
        CreateESP(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= Player then
        CreateESP(player)
    end
end)
end})

-- settings
local settings = {
   defaultcolor = Color3.fromRGB(255,255,255),
   teamcheck = false,
   teamcolor = true,
   espEnabled = false -- Добавлено для хранения состояния toggle
};

-- services
local runService = game:GetService("RunService");
local players = game:GetService("Players");

-- variables
local localPlayer = players.LocalPlayer;
local camera = workspace.CurrentCamera;

-- functions
local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new;
local tan, rad = math.tan, math.rad;
local round = function(...) local a = {}; for i,v in next, table.pack(...) do a[i] = math.round(v); end return unpack(a); end;
local wtvp = function(...) local a, b = camera.WorldToViewportPoint(camera, ...) return newVector2(a.X, a.Y), b, a.Z end;

local espCache = {};
local function createEsp(player)
   local drawings = {};
   
   drawings.box = newDrawing("Square");
   drawings.box.Thickness = 1;
   drawings.box.Filled = false;
   drawings.box.Color = settings.defaultcolor;
   drawings.box.Visible = false;
   drawings.box.ZIndex = 2;

   drawings.boxoutline = newDrawing("Square");
   drawings.boxoutline.Thickness = 3;
   drawings.boxoutline.Filled = false;
   drawings.boxoutline.Color = newColor3();
   drawings.boxoutline.Visible = false;
   drawings.boxoutline.ZIndex = 1;

   espCache[player] = drawings;
end

local function removeEsp(player)
   if rawget(espCache, player) then
       for _, drawing in next, espCache[player] do
           drawing:Remove();
       end
       espCache[player] = nil;
   end
end

local function updateEsp(player, esp)
   local character = player and player.Character;
   if character then
       local cframe = character:GetModelCFrame();
       local position, visible, depth = wtvp(cframe.Position);
       esp.box.Visible = visible and settings.espEnabled; -- Изменено для учета состояния toggle
       esp.boxoutline.Visible = visible and settings.espEnabled; -- Изменено для учета состояния toggle

       if cframe and visible then
           local scaleFactor = 1 / (depth * tan(rad(camera.FieldOfView / 2)) * 2) * 1000;
           local width, height = round(4 * scaleFactor, 5 * scaleFactor);
           local x, y = round(position.X, position.Y);

           esp.box.Size = newVector2(width, height);
           esp.box.Position = newVector2(round(x - width / 2, y - height / 2));
           esp.box.Color = settings.teamcolor and player.TeamColor.Color or settings.defaultcolor;

           esp.boxoutline.Size = esp.box.Size;
           esp.boxoutline.Position = esp.box.Position;
       end
   else
       esp.box.Visible = false;
       esp.boxoutline.Visible = false;
   end
end

-- main
for _, player in next, players:GetPlayers() do
   if player ~= localPlayer then
       createEsp(player);
   end
end

players.PlayerAdded:Connect(function(player)
   createEsp(player);
end);

players.PlayerRemoving:Connect(function(player)
   removeEsp(player);
end)

runService:BindToRenderStep("esp", Enum.RenderPriority.Camera.Value, function()
   for player, drawings in next, espCache do
       if settings.teamcheck and player.Team == localPlayer.Team then
           continue;
       end

       if drawings and player ~= localPlayer then
           updateEsp(player, drawings);
       end
   end
end)

-- Toggle для включения и выключения ESP
local toggle = esp:Toggle({
    Name = "Box ESP",
    Flag = "ToggleESP",
    callback = function(state)
        settings.espEnabled = state
    end
})

local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()
local Camera = game:GetService("Workspace").CurrentCamera
local ESPEnabled = false -- Переменная для хранения состояния toggle

local function DrawLine()
    local l = Drawing.new("Line")
    l.Visible = false
    l.From = Vector2.new(0, 0)
    l.To = Vector2.new(1, 1)
    l.Color = Color3.fromRGB(255, 255, 255)
    l.Thickness = 2
    l.Transparency = 1
    return l
end

local function DrawESP(plr)
    repeat wait() until plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil
    local limbs = {}
    local R15 = (plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R15) and true or false
    if R15 then 
        limbs = {
            -- Spine
            Head_UpperTorso = DrawLine(),
            UpperTorso_LowerTorso = DrawLine(),
            -- Left Arm
            UpperTorso_LeftUpperArm = DrawLine(),
            LeftUpperArm_LeftLowerArm = DrawLine(),
            LeftLowerArm_LeftHand = DrawLine(),
            -- Right Arm
            UpperTorso_RightUpperArm = DrawLine(),
            RightUpperArm_RightLowerArm = DrawLine(),
            RightLowerArm_RightHand = DrawLine(),
            -- Left Leg
            LowerTorso_LeftUpperLeg = DrawLine(),
            LeftUpperLeg_LeftLowerLeg = DrawLine(),
            LeftLowerLeg_LeftFoot = DrawLine(),
            -- Right Leg
            LowerTorso_RightUpperLeg = DrawLine(),
            RightUpperLeg_RightLowerLeg = DrawLine(),
            RightLowerLeg_RightFoot = DrawLine(),
        }
    else 
        limbs = {
            Head_Spine = DrawLine(),
            Spine = DrawLine(),
            LeftArm = DrawLine(),
            LeftArm_UpperTorso = DrawLine(),
            RightArm = DrawLine(),
            RightArm_UpperTorso = DrawLine(),
            LeftLeg = DrawLine(),
            LeftLeg_LowerTorso = DrawLine(),
            RightLeg = DrawLine(),
            RightLeg_LowerTorso = DrawLine()
        }
    end
    local function Visibility(state)
        for i, v in pairs(limbs) do
            v.Visible = state
        end
    end

    local function Colorize(color)
        for i, v in pairs(limbs) do
            v.Color = color
        end
    end

    local function UpdaterR15()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if ESPEnabled and plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 then
                local HUM, vis = Camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                if vis then
                    -- Head
                    local H = Camera:WorldToViewportPoint(plr.Character.Head.Position)
                    if limbs.Head_UpperTorso.From ~= Vector2.new(H.X, H.Y) then
                        --Spine
                        local UT = Camera:WorldToViewportPoint(plr.Character.UpperTorso.Position)
                        local LT = Camera:WorldToViewportPoint(plr.Character.LowerTorso.Position)
                        -- Left Arm
                        local LUA = Camera:WorldToViewportPoint(plr.Character.LeftUpperArm.Position)
                        local LLA = Camera:WorldToViewportPoint(plr.Character.LeftLowerArm.Position)
                        local LH = Camera:WorldToViewportPoint(plr.Character.LeftHand.Position)
                        -- Right Arm
                        local RUA = Camera:WorldToViewportPoint(plr.Character.RightUpperArm.Position)
                        local RLA = Camera:WorldToViewportPoint(plr.Character.RightLowerArm.Position)
                        local RH = Camera:WorldToViewportPoint(plr.Character.RightHand.Position)
                        -- Left leg
                        local LUL = Camera:WorldToViewportPoint(plr.Character.LeftUpperLeg.Position)
                        local LLL = Camera:WorldToViewportPoint(plr.Character.LeftLowerLeg.Position)
                        local LF = Camera:WorldToViewportPoint(plr.Character.LeftFoot.Position)
                        -- Right leg
                        local RUL = Camera:WorldToViewportPoint(plr.Character.RightUpperLeg.Position)
                        local RLL = Camera:WorldToViewportPoint(plr.Character.RightLowerLeg.Position)
                        local RF = Camera:WorldToViewportPoint(plr.Character.RightFoot.Position)

                        --Head
                        limbs.Head_UpperTorso.From = Vector2.new(H.X, H.Y)
                        limbs.Head_UpperTorso.To = Vector2.new(UT.X, UT.Y)

                        --Spine
                        limbs.UpperTorso_LowerTorso.From = Vector2.new(UT.X, UT.Y)
                        limbs.UpperTorso_LowerTorso.To = Vector2.new(LT.X, LT.Y)

                        -- Left Arm
                        limbs.UpperTorso_LeftUpperArm.From = Vector2.new(UT.X, UT.Y)
                        limbs.UpperTorso_LeftUpperArm.To = Vector2.new(LUA.X, LUA.Y)

                        limbs.LeftUpperArm_LeftLowerArm.From = Vector2.new(LUA.X, LUA.Y)
                        limbs.LeftUpperArm_LeftLowerArm.To = Vector2.new(LLA.X, LLA.Y)

                        limbs.LeftLowerArm_LeftHand.From = Vector2.new(LLA.X, LLA.Y)
                        limbs.LeftLowerArm_LeftHand.To = Vector2.new(LH.X, LH.Y)

                        -- Right Arm
                        limbs.UpperTorso_RightUpperArm.From = Vector2.new(UT.X, UT.Y)
                        limbs.UpperTorso_RightUpperArm.To = Vector2.new(RUA.X, RUA.Y)

                        limbs.RightUpperArm_RightLowerArm.From = Vector2.new(RUA.X, RUA.Y)
                        limbs.RightUpperArm_RightLowerArm.To = Vector2.new(RLA.X, RLA.Y)

                        limbs.RightLowerArm_RightHand.From = Vector2.new(RLA.X, RLA.Y)
                        limbs.RightLowerArm_RightHand.To = Vector2.new(RH.X, RH.Y)

                        -- Left Leg
                        limbs.LowerTorso_LeftUpperLeg.From = Vector2.new(LT.X, LT.Y)
                        limbs.LowerTorso_LeftUpperLeg.To = Vector2.new(LUL.X, LUL.Y)

                        limbs.LeftUpperLeg_LeftLowerLeg.From = Vector2.new(LUL.X, LUL.Y)
                        limbs.LeftUpperLeg_LeftLowerLeg.To = Vector2.new(LLL.X, LLL.Y)

                        limbs.LeftLowerLeg_LeftFoot.From = Vector2.new(LLL.X, LLL.Y)
                        limbs.LeftLowerLeg_LeftFoot.To = Vector2.new(LF.X, LF.Y)

                        -- Right Leg
                        limbs.LowerTorso_RightUpperLeg.From = Vector2.new(LT.X, LT.Y)
                        limbs.LowerTorso_RightUpperLeg.To = Vector2.new(RUL.X, RUL.Y)

                        limbs.RightUpperLeg_RightLowerLeg.From = Vector2.new(RUL.X, RUL.Y)
                        limbs.RightUpperLeg_RightLowerLeg.To = Vector2.new(RLL.X, RLL.Y)

                        limbs.RightLowerLeg_RightFoot.From = Vector2.new(RLL.X, RLL.Y)
                        limbs.RightLowerLeg_RightFoot.To = Vector2.new(RF.X, RF.Y)
                    end

                    if limbs.Head_UpperTorso.Visible ~= true then
                        Visibility(true)
                    end
                else 
                    if limbs.Head_UpperTorso.Visible ~= false then
                        Visibility(false)
                    end
                end
            else 
                if limbs.Head_UpperTorso.Visible ~= false then
                    Visibility(false)
                end
                if game.Players:FindFirstChild(plr.Name) == nil then 
                    for i, v in pairs(limbs) do
                        v:Remove()
                    end
                    connection:Disconnect()
                end
            end
        end)
    end

    local function UpdaterR6()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if ESPEnabled and plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 then
                local HUM, vis = Camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                if vis then
                    local H = Camera:WorldToViewportPoint(plr.Character.Head.Position)
                    if limbs.Head_Spine.From ~= Vector2.new(H.X, H.Y) then
                        local T_Height = plr.Character.Torso.Size.Y/2 - 0.2
                        local UT = Camera:WorldToViewportPoint((plr.Character.Torso.CFrame * CFrame.new(0, T_Height, 0)).p)
                        local LT = Camera:WorldToViewportPoint((plr.Character.Torso.CFrame * CFrame.new(0, -T_Height, 0)).p)

                        local LA_Height = plr.Character["Left Arm"].Size.Y/2 - 0.2
                        local LUA = Camera:WorldToViewportPoint((plr.Character["Left Arm"].CFrame * CFrame.new(0, LA_Height, 0)).p)
                        local LLA = Camera:WorldToViewportPoint((plr.Character["Left Arm"].CFrame * CFrame.new(0, -LA_Height, 0)).p)

                        local RA_Height = plr.Character["Right Arm"].Size.Y/2 - 0.2
                        local RUA = Camera:WorldToViewportPoint((plr.Character["Right Arm"].CFrame * CFrame.new(0, RA_Height, 0)).p)
                        local RLA = Camera:WorldToViewportPoint((plr.Character["Right Arm"].CFrame * CFrame.new(0, -RA_Height, 0)).p)

                        local LL_Height = plr.Character["Left Leg"].Size.Y/2 - 0.2
                        local LUL = Camera:WorldToViewportPoint((plr.Character["Left Leg"].CFrame * CFrame.new(0, LL_Height, 0)).p)
                        local LLL = Camera:WorldToViewportPoint((plr.Character["Left Leg"].CFrame * CFrame.new(0, -LL_Height, 0)).p)

                        local RL_Height = plr.Character["Right Leg"].Size.Y/2 - 0.2
                        local RUL = Camera:WorldToViewportPoint((plr.Character["Right Leg"].CFrame * CFrame.new(0, RL_Height, 0)).p)
                        local RLL = Camera:WorldToViewportPoint((plr.Character["Right Leg"].CFrame * CFrame.new(0, -RL_Height, 0)).p)

                        -- Head
                        limbs.Head_Spine.From = Vector2.new(H.X, H.Y)
                        limbs.Head_Spine.To = Vector2.new(UT.X, UT.Y)

                        --Spine
                        limbs.Spine.From = Vector2.new(UT.X, UT.Y)
                        limbs.Spine.To = Vector2.new(LT.X, LT.Y)

                        --Left Arm
                        limbs.LeftArm.From = Vector2.new(LUA.X, LUA.Y)
                        limbs.LeftArm.To = Vector2.new(LLA.X, LLA.Y)

                        limbs.LeftArm_UpperTorso.From = Vector2.new(UT.X, UT.Y)
                        limbs.LeftArm_UpperTorso.To = Vector2.new(LUA.X, LUA.Y)

                        --Right Arm
                        limbs.RightArm.From = Vector2.new(RUA.X, RUA.Y)
                        limbs.RightArm.To = Vector2.new(RLA.X, RLA.Y)

                        limbs.RightArm_UpperTorso.From = Vector2.new(UT.X, UT.Y)
                        limbs.RightArm_UpperTorso.To = Vector2.new(RUA.X, RUA.Y)

                        --Left Leg
                        limbs.LeftLeg.From = Vector2.new(LUL.X, LUL.Y)
                        limbs.LeftLeg.To = Vector2.new(LLL.X, LLL.Y)

                        limbs.LeftLeg_LowerTorso.From = Vector2.new(LT.X, LT.Y)
                        limbs.LeftLeg_LowerTorso.To = Vector2.new(LUL.X, LUL.Y)

                        --Right Leg
                        limbs.RightLeg.From = Vector2.new(RUL.X, RUL.Y)
                        limbs.RightLeg.To = Vector2.new(RLL.X, RLL.Y)

                        limbs.RightLeg_LowerTorso.From = Vector2.new(LT.X, LT.Y)
                        limbs.RightLeg_LowerTorso.To = Vector2.new(RUL.X, RUL.Y)
                    end

                    if limbs.Head_Spine.Visible ~= true then
                        Visibility(true)
                    end
                else 
                    if limbs.Head_Spine.Visible ~= false then
                        Visibility(false)
                    end
                end
            else 
                if limbs.Head_Spine.Visible ~= false then
                    Visibility(false)
                end
                if game.Players:FindFirstChild(plr.Name) == nil then 
                    for i, v in pairs(limbs) do
                        v:Remove()
                    end
                    connection:Disconnect()
                end
            end
        end)
    end

    if R15 then
        coroutine.wrap(UpdaterR15)()
    else 
        coroutine.wrap(UpdaterR6)()
    end
end

for i, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v.Name ~= Player.Name then
        DrawESP(v)
    end
end

game.Players.PlayerAdded:Connect(function(newplr)
    if newplr.Name ~= Player.Name then
        DrawESP(newplr)
    end
end)

-- Toggle для включения и выключения ESP
local toggle = esp:Toggle({
    Name = "Skeleton ESP",
    Flag = "Toggle",
    callback = function(bool)
        ESPEnabled = bool
        if not bool then
            for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
                if plr.Name ~= Player.Name then
                    for _, limb in pairs(plr.Character:GetChildren()) do
                        if limb:IsA("BasePart") then
                            local esp = limb:FindFirstChild("ESPLine")
                            if esp then
                                esp.Visible = false
                            end
                        end
                    end
                end
            end
        end
    end
})

-- settings
local settings = {
    defaultcolor = Color3.fromRGB(255, 255, 255), -- Изменено на белый цвет
    tracersVisible = false, -- Трассеры не будут появляться сразу при инжекте скрипта
    tracerMode = "Custom", -- Переменная для хранения режима tracers
    customX = 50, -- Начальное значение для кастомной X координаты
    customY = 50  -- Начальное значение для кастомной Y координаты
};

-- services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = game:GetService("Workspace").CurrentCamera
local UserInputService = game:GetService("UserInputService") -- Добавлено для FromMouse

-- functions
local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new
local tan, rad = math.tan, math.rad
local round = function(...) local a = {}; for i,v in next, table.pack(...) do a[i] = math.round(v); end return unpack(a); end;
local wtvp = function(...) local a, b = Camera.WorldToViewportPoint(Camera, ...) return newVector2(a.X, a.Y), b, a.Z end;

local espCache = {};
local function createEsp(player)
    local drawings = {};
    
    drawings.tracer = newDrawing("Line")
    drawings.tracer.Thickness = 1
    drawings.tracer.Transparency = 0.7
    drawings.tracer.Color = settings.defaultcolor
    drawings.tracer.Visible = false

    espCache[player] = drawings;
end

local function removeEsp(player)
    if rawget(espCache, player) then
        for _, drawing in next, espCache[player] do
            drawing:Remove();
        end
        espCache[player] = nil;
    end
end

local function updateEsp(player, esp)
    local character = player and player.Character;
    if character then
        local cframe = character:GetModelCFrame();
        local position, visible, depth = wtvp(cframe.Position);
        esp.tracer.Visible = visible and settings.tracersVisible; -- Изменено для учета состояния toggle

        if cframe and visible then
            local scaleFactor = 1 / (depth * tan(rad(Camera.FieldOfView / 2)) * 2) * 1000;
            local width, height = round(4 * scaleFactor, 5 * scaleFactor);
            local x, y = round(position.X, position.Y);

            if settings.tracerMode == "Custom" then
                esp.tracer.From = newVector2(settings.customX, settings.customY)
            elseif settings.tracerMode == "FromMouse" then
                esp.tracer.From = newVector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
            end

            esp.tracer.To = newVector2(x, y)
        end
    else
        esp.tracer.Visible = false;
    end
end

-- main
for _, player in next, Players:GetPlayers() do
    if player ~= Players.LocalPlayer then
        createEsp(player);
    end
end

Players.PlayerAdded:Connect(function(player)
    createEsp(player);
end);

Players.PlayerRemoving:Connect(function(player)
    removeEsp(player);
end)

RunService:BindToRenderStep("esp", Enum.RenderPriority.Camera.Value, function()
    for player, drawings in next, espCache do
        if drawings and player ~= Players.LocalPlayer then
            updateEsp(player, drawings);
        end
    end
end)

-- Toggle для включения и выключения ESP
local toggle = esp:Toggle({
    Name = "Tracers",
    Flag = "ToggleTracers",
    callback = function(state)
        settings.tracersVisible = state
    end
})

-- Dropdown для выбора режима tracers
local dropdown = esp:Dropdown({
    Default = "Custom",
    Content = {"Custom", "FromMouse"},
    MultiChoice = false,
    Flag = "TracerMode",
    Callback = function(opt)
        settings.tracerMode = opt
    end
})

-- Слайдер для настройки кастомной X координаты
local sliderX = esp:Slider({
    Name = "Custom X",
    Min = 0,
    Max = 2000,
    Default = 900,
    Flag = "CustomX",
    Callback = function(value)
        settings.customX = value
    end
})

-- Слайдер для настройки кастомной Y координаты
local sliderY = esp:Slider({
    Name = "Custom Y",
    Min = 0,
    Max = 1000,
    Default = 1000,
    Flag = "CustomY",
    Callback = function(value)
        settings.customY = value
    end
})

